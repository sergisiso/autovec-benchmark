Runtime Arithmetic Parameters
(are they all TYPE)
S000 ap_n1 1
S1112 ap_n1 1
S2251 ap_n0 0
s252 ap_n0 0
s254 ap_n5 5
s255 ap_n0333 0.333
s256 ap_n1 1
s258 ap_n1 1
s2710 ap_n1 1 (but path not executed?)
s281 ap_n1 1
s1281 ap_n1 1
s291 ap_n05 0.5
s292 ap_n0333 0.333
s2102 ap_n0 0, ap_n1 1
s31111 ap_n0 0 (test ap_n0 0)
s313 ap_n0 0
s317 ap_n099 0.99, ap_n1 1
s453 ap_n2 2


Bound Arithmetic Parameters
almost all have LEN reference
s31111 (test function) bp_n4 4

Index Arithmetic Parameters
s162 ip_n0 0
s332 ip_n_2 -2


Conditional Arithmetic Parameters
(most conditionals use num 0, is the performance result due to that compare to 0 is quicker?)
(most of them are TYPE)
s123 cp_n0 0
s124 cp_n0 0
s161 cp_n0 0
s1161 cp_n0 0
s271 cp_n0 0
s273 cp_n0 0
s274 cp_n0 0
s275 cp_n0 0
s276 cp_n1 1
s277 cp_n0 0
s278 cp_n0 0
s279 cp_n0 0
s1279 cp_n0 0
s2710 cp_n10 10, cp_n0 0
s2711 cp_n0 0
s3111 cp_n0 0
s3112 cp_n0 0
s331 cp_n0 0
s332 cp_n_1 -1
s341 cp_n0 0
s342 cp_n0 0
s343 cp_n0 0
s441 cp_n0 0
s443 cp_n0 0
s481 cp_n0 0

What to do with function parameters? Is the compiler optimizing it already?
s171
s242
s272


There is some tests where the arithmetic constat is to set up a starting value, eg: sum = 0; This probably don't have any effect in performance. Should not be considered?

There is tests where the original tsc already may have compiler hidden values, e.g: max = abs(a[0]); in test 3113. Should I modify the original case to make a clear distinction btw compiler-time and runtime performance comparison?
